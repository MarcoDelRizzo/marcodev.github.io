import{a as J,f as ot,d as ee,V as z,n as Y,bD as se,bM as tt,bP as Q,y as ie,s as me,t as xe,F as En,bC as he}from"./three@0.169.15.js";const oe=0,we=1,Ae=2,gs=0,Bs=1,Ln=2,en=1.25,Rn=1,H=6*4+4+4,D=H/4,bn=65535,Ps=bn<<16,Yt=Math.pow(2,-24),Sn=Symbol("SKIP_GENERATION"),re={strategy:oe,maxDepth:40,maxLeafSize:10,useSharedArrayBuffer:!1,setBoundingBox:!0,onProgress:null,indirect:!1,verbose:!0,range:null,[Sn]:!1};function L(s,t,n){return n.min.x=t[s],n.min.y=t[s+1],n.min.z=t[s+2],n.max.x=t[s+3],n.max.y=t[s+4],n.max.z=t[s+5],n}function Vn(s){let t=-1,n=-1/0;for(let e=0;e<3;e++){const i=s[e+3]-s[e];i>n&&(n=i,t=e)}return t}function Dn(s,t){t.set(s)}function Fn(s,t,n){let e,i;for(let c=0;c<3;c++){const o=c+3;e=s[c],i=t[c],n[c]=e<i?e:i,e=s[o],i=t[o],n[o]=e>i?e:i}}function Ut(s,t,n){for(let e=0;e<3;e++){const i=t[s+2*e],c=t[s+2*e+1],o=i-c,l=i+c;o<n[e]&&(n[e]=o),l>n[e+3]&&(n[e+3]=l)}}function gt(s){const t=s[3]-s[0],n=s[4]-s[1],e=s[5]-s[2];return 2*(t*n+n*e+e*t)}function F(s,t){return t[s+15]===bn}function $(s,t){return t[s+6]}function k(s,t){return t[s+14]}function N(s){return s+D}function q(s,t){const n=t[s+6];return s+n*D}function _n(s,t){return t[s+7]}function Ts(s){return s}function sn(s,t,n,e,i){let c=1/0,o=1/0,l=1/0,r=-1/0,y=-1/0,u=-1/0,f=1/0,a=1/0,p=1/0,w=-1/0,g=-1/0,B=-1/0;const A=s.offset||0;for(let d=(t-A)*6,m=(t+n-A)*6;d<m;d+=6){const x=s[d+0],h=s[d+1],S=x-h,P=x+h;S<c&&(c=S),P>r&&(r=P),x<f&&(f=x),x>w&&(w=x);const _=s[d+2],M=s[d+3],T=_-M,I=_+M;T<o&&(o=T),I>y&&(y=I),_<a&&(a=_),_>g&&(g=_);const b=s[d+4],v=s[d+5],C=b-v,U=b+v;C<l&&(l=C),U>u&&(u=U),b<p&&(p=b),b>B&&(B=b)}e[0]=c,e[1]=o,e[2]=l,e[3]=r,e[4]=y,e[5]=u,i[0]=f,i[1]=a,i[2]=p,i[3]=w,i[4]=g,i[5]=B}const j=32,ge=(s,t)=>s.candidate-t.candidate,et=new Array(j).fill().map(()=>({count:0,bounds:new Float32Array(6),rightCacheBounds:new Float32Array(6),leftCacheBounds:new Float32Array(6),candidate:0})),Et=new Float32Array(6);function Be(s,t,n,e,i,c){let o=-1,l=0;if(c===oe)o=Vn(t),o!==-1&&(l=(t[o]+t[o+3])/2);else if(c===we)o=Vn(s),o!==-1&&(l=Pe(n,e,i,o));else if(c===Ae){const r=gt(s);let y=en*i;const u=n.offset||0,f=(e-u)*6,a=(e+i-u)*6;for(let p=0;p<3;p++){const w=t[p],A=(t[p+3]-w)/j;if(i<j/4){const d=[...et];d.length=i;let m=0;for(let h=f;h<a;h+=6,m++){const S=d[m];S.candidate=n[h+2*p],S.count=0;const{bounds:P,leftCacheBounds:_,rightCacheBounds:M}=S;for(let T=0;T<3;T++)M[T]=1/0,M[T+3]=-1/0,_[T]=1/0,_[T+3]=-1/0,P[T]=1/0,P[T+3]=-1/0;Ut(h,n,P)}d.sort(ge);let x=i;for(let h=0;h<x;h++){const S=d[h];for(;h+1<x&&d[h+1].candidate===S.candidate;)d.splice(h+1,1),x--}for(let h=f;h<a;h+=6){const S=n[h+2*p];for(let P=0;P<x;P++){const _=d[P];S>=_.candidate?Ut(h,n,_.rightCacheBounds):(Ut(h,n,_.leftCacheBounds),_.count++)}}for(let h=0;h<x;h++){const S=d[h],P=S.count,_=i-S.count,M=S.leftCacheBounds,T=S.rightCacheBounds;let I=0;P!==0&&(I=gt(M)/r);let b=0;_!==0&&(b=gt(T)/r);const v=Rn+en*(I*P+b*_);v<y&&(o=p,y=v,l=S.candidate)}}else{for(let x=0;x<j;x++){const h=et[x];h.count=0,h.candidate=w+A+x*A;const S=h.bounds;for(let P=0;P<3;P++)S[P]=1/0,S[P+3]=-1/0}for(let x=f;x<a;x+=6){let P=~~((n[x+2*p]-w)/A);P>=j&&(P=j-1);const _=et[P];_.count++,Ut(x,n,_.bounds)}const d=et[j-1];Dn(d.bounds,d.rightCacheBounds);for(let x=j-2;x>=0;x--){const h=et[x],S=et[x+1];Fn(h.bounds,S.rightCacheBounds,h.rightCacheBounds)}let m=0;for(let x=0;x<j-1;x++){const h=et[x],S=h.count,P=h.bounds,M=et[x+1].rightCacheBounds;S!==0&&(m===0?Dn(P,Et):Fn(P,Et,Et)),m+=S;let T=0,I=0;m!==0&&(T=gt(Et)/r);const b=i-m;b!==0&&(I=gt(M)/r);const v=Rn+en*(T*m+I*b);v<y&&(o=p,y=v,l=h.candidate)}}}}else console.warn(`BVH: Invalid build strategy value ${c} used.`);return{axis:o,pos:l}}function Pe(s,t,n,e){let i=0;const c=s.offset;for(let o=t,l=t+n;o<l;o++)i+=s[(o-c)*6+e*2];return i/n}class on{constructor(){this.boundingData=new Float32Array(6)}}function Te(s,t,n,e,i,c){let o=e,l=e+i-1;const r=c.pos,y=c.axis*2,u=n.offset||0;for(;;){for(;o<=l&&n[(o-u)*6+y]<r;)o++;for(;o<=l&&n[(l-u)*6+y]>=r;)l--;if(o<l){for(let f=0;f<t;f++){let a=s[o*t+f];s[o*t+f]=s[l*t+f],s[l*t+f]=a}for(let f=0;f<6;f++){const a=o-u,p=l-u,w=n[a*6+f];n[a*6+f]=n[p*6+f],n[p*6+f]=w}o++,l--}else return o}}let ce,Kt,yn,le;const be=Math.pow(2,32);function dn(s){return"count"in s?1:1+dn(s.left)+dn(s.right)}function Se(s,t,n){return ce=new Float32Array(n),Kt=new Uint32Array(n),yn=new Uint16Array(n),le=new Uint8Array(n),mn(s,t)}function mn(s,t){const n=s/4,e=s/2,i="count"in t,c=t.boundingData;for(let o=0;o<6;o++)ce[n+o]=c[o];if(i)return t.buffer?(le.set(new Uint8Array(t.buffer),s),s+t.buffer.byteLength):(Kt[n+6]=t.offset,yn[e+14]=t.count,yn[e+15]=bn,s+H);{const{left:o,right:l,splitAxis:r}=t,y=s+H;let u=mn(y,o);const f=s/H,p=u/H-f;if(p>be)throw new Error("MeshBVH: Cannot store relative child node offset greater than 32 bits.");return Kt[n+6]=p,Kt[n+7]=r,mn(u,l)}}function _e(s,t,n,e,i){const{maxDepth:c,verbose:o,maxLeafSize:l,strategy:r,onProgress:y}=i,u=s.primitiveBuffer,f=s.primitiveBufferStride,a=new Float32Array(6);let p=!1;const w=new on;return sn(t,n,e,w.boundingData,a),B(w,n,e,a),w;function g(A){y&&y(A/e)}function B(A,d,m,x=null,h=0){if(!p&&h>=c&&(p=!0,o&&console.warn(`BVH: Max depth of ${c} reached when generating BVH. Consider increasing maxDepth.`)),m<=l||h>=c)return g(d+m),A.offset=d,A.count=m,A;const S=Be(A.boundingData,x,t,d,m,r);if(S.axis===-1)return g(d+m),A.offset=d,A.count=m,A;const P=Te(u,f,t,d,m,S);if(P===d||P===d+m)g(d+m),A.offset=d,A.count=m;else{A.splitAxis=S.axis;const _=new on,M=d,T=P-d;A.left=_,sn(t,M,T,_.boundingData,a),B(_,M,T,a,h+1);const I=new on,b=P,v=m-T;A.right=I,sn(t,b,v,I.boundingData,a),B(I,b,v,a,h+1)}return A}}function Me(s,t){const n=t.useSharedArrayBuffer?SharedArrayBuffer:ArrayBuffer,e=s.getRootRanges(t.range),i=e[0],c=e[e.length-1],o={offset:i.offset,count:c.offset+c.count-i.offset},l=new Float32Array(6*o.count);l.offset=o.offset,s.computePrimitiveBounds(o.offset,o.count,l),s._roots=e.map(r=>{const y=_e(s,l,r.offset,r.count,t),u=dn(y),f=new n(H*u);return Se(0,y,f),f})}class Mn{constructor(t){this._getNewPrimitive=t,this._primitives=[]}getPrimitive(){const t=this._primitives;return t.length===0?this._getNewPrimitive():t.pop()}releasePrimitive(t){this._primitives.push(t)}}class Ie{constructor(){this.float32Array=null,this.uint16Array=null,this.uint32Array=null;const t=[];let n=null;this.setBuffer=e=>{n&&t.push(n),n=e,this.float32Array=new Float32Array(e),this.uint16Array=new Uint16Array(e),this.uint32Array=new Uint32Array(e)},this.clearBuffer=()=>{n=null,this.float32Array=null,this.uint16Array=null,this.uint32Array=null,t.length!==0&&this.setBuffer(t.pop())}}}const E=new Ie;let it,At;const ut=[],Lt=new Mn(()=>new J);function ve(s,t,n,e,i,c){it=Lt.getPrimitive(),At=Lt.getPrimitive(),ut.push(it,At),E.setBuffer(s._roots[t]);const o=xn(0,s.geometry,n,e,i,c);E.clearBuffer(),Lt.releasePrimitive(it),Lt.releasePrimitive(At),ut.pop(),ut.pop();const l=ut.length;return l>0&&(At=ut[l-1],it=ut[l-2]),o}function xn(s,t,n,e,i=null,c=0,o=0){const{float32Array:l,uint16Array:r,uint32Array:y}=E;let u=s*2;if(F(u,r)){const a=$(s,y),p=k(u,r);return L(s,l,it),e(a,p,!1,o,c+s/D,it)}else{let T=function(b){const{uint16Array:v,uint32Array:C}=E;let U=b*2;for(;!F(U,v);)b=N(b),U=b*2;return $(b,C)},I=function(b){const{uint16Array:v,uint32Array:C}=E;let U=b*2;for(;!F(U,v);)b=q(b,C),U=b*2;return $(b,C)+k(U,v)};const a=N(s),p=q(s,y);let w=a,g=p,B,A,d,m;if(i&&(d=it,m=At,L(w,l,d),L(g,l,m),B=i(d),A=i(m),A<B)){w=p,g=a;const b=B;B=A,A=b,d=m}d||(d=it,L(w,l,d));const x=F(w*2,r),h=n(d,x,B,o+1,c+w/D);let S;if(h===Ln){const b=T(w),C=I(w)-b;S=e(b,C,!0,o+1,c+w/D,d)}else S=h&&xn(w,t,n,e,i,c,o+1);if(S)return!0;m=At,L(g,l,m);const P=F(g*2,r),_=n(m,P,A,o+1,c+g/D);let M;if(_===Ln){const b=T(g),C=I(g)-b;M=e(b,C,!0,o+1,c+g/D,m)}else M=_&&xn(g,t,n,e,i,c,o+1);return!!M}}const Ct=new E.constructor,Wt=new E.constructor,st=new Mn(()=>new J),pt=new J,yt=new J,rn=new J,cn=new J;let ln=!1;function Ce(s,t,n,e){if(ln)throw new Error("MeshBVH: Recursive calls to bvhcast not supported.");ln=!0;const i=s._roots,c=t._roots;let o,l=0,r=0;const y=new ot().copy(n).invert();for(let u=0,f=i.length;u<f;u++){Ct.setBuffer(i[u]),r=0;const a=st.getPrimitive();L(0,Ct.float32Array,a),a.applyMatrix4(y);for(let p=0,w=c.length;p<w&&(Wt.setBuffer(c[p]),o=K(0,0,n,y,e,l,r,0,0,a),Wt.clearBuffer(),r+=c[p].byteLength/H,!o);p++);if(st.releasePrimitive(a),Ct.clearBuffer(),l+=i[u].byteLength/H,o)break}return ln=!1,o}function K(s,t,n,e,i,c=0,o=0,l=0,r=0,y=null,u=!1){let f,a;u?(f=Wt,a=Ct):(f=Ct,a=Wt);const p=f.float32Array,w=f.uint32Array,g=f.uint16Array,B=a.float32Array,A=a.uint32Array,d=a.uint16Array,m=s*2,x=t*2,h=F(m,g),S=F(x,d);let P=!1;if(S&&h)u?P=i($(t,A),k(t*2,d),$(s,w),k(s*2,g),r,o+t/D,l,c+s/D):P=i($(s,w),k(s*2,g),$(t,A),k(t*2,d),l,c+s/D,r,o+t/D);else if(S){const _=st.getPrimitive();L(t,B,_),_.applyMatrix4(n);const M=N(s),T=q(s,w);L(M,p,pt),L(T,p,yt);const I=_.intersectsBox(pt),b=_.intersectsBox(yt);P=I&&K(t,M,e,n,i,o,c,r,l+1,_,!u)||b&&K(t,T,e,n,i,o,c,r,l+1,_,!u),st.releasePrimitive(_)}else{const _=N(t),M=q(t,A);L(_,B,rn),L(M,B,cn);const T=y.intersectsBox(rn),I=y.intersectsBox(cn);if(T&&I)P=K(s,_,n,e,i,c,o,l,r+1,y,u)||K(s,M,n,e,i,c,o,l,r+1,y,u);else if(T)if(h)P=K(s,_,n,e,i,c,o,l,r+1,y,u);else{const b=st.getPrimitive();b.copy(rn).applyMatrix4(n);const v=N(s),C=q(s,w);L(v,p,pt),L(C,p,yt);const U=b.intersectsBox(pt),R=b.intersectsBox(yt);P=U&&K(_,v,e,n,i,o,c,r,l+1,b,!u)||R&&K(_,C,e,n,i,o,c,r,l+1,b,!u),st.releasePrimitive(b)}else if(I)if(h)P=K(s,M,n,e,i,c,o,l,r+1,y,u);else{const b=st.getPrimitive();b.copy(cn).applyMatrix4(n);const v=N(s),C=q(s,w);L(v,p,pt),L(C,p,yt);const U=b.intersectsBox(pt),R=b.intersectsBox(yt);P=U&&K(M,v,e,n,i,o,c,r,l+1,b,!u)||R&&K(M,C,e,n,i,o,c,r,l+1,b,!u),st.releasePrimitive(b)}}return P}const Nn=new J,dt=new Float32Array(6);class ze{constructor(){this._roots=null,this.primitiveBuffer=null,this.primitiveBufferStride=null}init(t){t={...re,...t},Me(this,t)}getRootRanges(){throw new Error("BVH: getRootRanges() not implemented")}writePrimitiveBounds(){throw new Error("BVH: writePrimitiveBounds() not implemented")}writePrimitiveRangeBounds(t,n,e,i){let c=1/0,o=1/0,l=1/0,r=-1/0,y=-1/0,u=-1/0;for(let f=t,a=t+n;f<a;f++){this.writePrimitiveBounds(f,dt,0);const[p,w,g,B,A,d]=dt;p<c&&(c=p),B>r&&(r=B),w<o&&(o=w),A>y&&(y=A),g<l&&(l=g),d>u&&(u=d)}return e[i+0]=c,e[i+1]=o,e[i+2]=l,e[i+3]=r,e[i+4]=y,e[i+5]=u,e}computePrimitiveBounds(t,n,e){const i=e.offset||0;for(let c=t,o=t+n;c<o;c++){this.writePrimitiveBounds(c,dt,0);const[l,r,y,u,f,a]=dt,p=(l+u)/2,w=(r+f)/2,g=(y+a)/2,B=(u-l)/2,A=(f-r)/2,d=(a-y)/2,m=(c-i)*6;e[m+0]=p,e[m+1]=B+(Math.abs(p)+B)*Yt,e[m+2]=w,e[m+3]=A+(Math.abs(w)+A)*Yt,e[m+4]=g,e[m+5]=d+(Math.abs(g)+d)*Yt}return e}shiftPrimitiveOffsets(t){const n=this._indirectBuffer;if(n)for(let e=0,i=n.length;e<i;e++)n[e]+=t;else{const e=this._roots;for(let i=0;i<e.length;i++){const c=e[i],o=new Uint32Array(c),l=new Uint16Array(c),r=c.byteLength/H;for(let y=0;y<r;y++){const u=D*y,f=2*u;F(f,l)&&(o[u+6]+=t)}}}}traverse(t,n=0){const e=this._roots[n],i=new Uint32Array(e),c=new Uint16Array(e);o(0);function o(l,r=0){const y=l*2,u=F(y,c);if(u){const f=i[l+6],a=c[y+14];t(r,u,new Float32Array(e,l*4,6),f,a)}else{const f=N(l),a=q(l,i),p=_n(l,i);t(r,u,new Float32Array(e,l*4,6),p)||(o(f,r+1),o(a,r+1))}}}refit(){const t=this._roots;for(let n=0,e=t.length;n<e;n++){const i=t[n],c=new Uint32Array(i),o=new Uint16Array(i),l=new Float32Array(i),r=i.byteLength/H;for(let y=r-1;y>=0;y--){const u=y*D,f=u*2;if(F(f,o)){const p=$(u,c),w=k(f,o);this.writePrimitiveRangeBounds(p,w,dt,0),l.set(dt,u)}else{const p=N(u),w=q(u,c);for(let g=0;g<3;g++){const B=l[p+g],A=l[p+g+3],d=l[w+g],m=l[w+g+3];l[u+g]=B<d?B:d,l[u+g+3]=A>m?A:m}}}}}getBoundingBox(t){return t.makeEmpty(),this._roots.forEach(e=>{L(0,new Float32Array(e),Nn),t.union(Nn)}),t}shapecast(t){let{boundsTraverseOrder:n,intersectsBounds:e,intersectsRange:i,intersectsPrimitive:c,scratchPrimitive:o,iterate:l}=t;if(i&&c){const f=i;i=(a,p,w,g,B)=>f(a,p,w,g,B)?!0:l(a,p,this,c,w,g,o)}else i||(c?i=(f,a,p,w)=>l(f,a,this,c,p,w,o):i=(f,a,p)=>p);let r=!1,y=0;const u=this._roots;for(let f=0,a=u.length;f<a;f++){const p=u[f];if(r=ve(this,f,e,i,n,y),r)break;y+=p.byteLength/H}return r}bvhcast(t,n,e){let{intersectsRanges:i}=e;return Ce(this,t,n,i)}}function Ue(){return typeof SharedArrayBuffer<"u"}function In(s){return s.index?s.index.count:s.attributes.position.count}function Qt(s){return In(s)/3}function Ee(s,t=ArrayBuffer){return s>65535?new Uint32Array(new t(4*s)):new Uint16Array(new t(2*s))}function Le(s,t){if(!s.index){const n=s.attributes.position.count,e=t.useSharedArrayBuffer?SharedArrayBuffer:ArrayBuffer,i=Ee(n,e);s.setIndex(new ee(i,1));for(let c=0;c<n;c++)i[c]=c}}function Re(s,t,n){const e=In(s)/n,i=t||s.drawRange,c=i.start/n,o=(i.start+i.count)/n,l=Math.max(0,c),r=Math.min(e,o)-l;return{offset:Math.floor(l),count:Math.floor(r)}}function Ve(s,t){return s.groups.map(n=>({offset:n.start/t,count:n.count/t}))}function qn(s,t,n){const e=Re(s,t,n),i=Ve(s,n);if(!i.length)return[e];const c=[],o=e.offset,l=e.offset+e.count,r=In(s)/n,y=[];for(const a of i){const{offset:p,count:w}=a,g=p,B=isFinite(w)?w:r-p,A=p+B;g<l&&A>o&&(y.push({pos:Math.max(o,g),isStart:!0}),y.push({pos:Math.min(l,A),isStart:!1}))}y.sort((a,p)=>a.pos!==p.pos?a.pos-p.pos:a.type==="end"?-1:1);let u=0,f=null;for(const a of y){const p=a.pos;u!==0&&p!==f&&c.push({offset:f,count:p-f}),u+=a.isStart?1:-1,f=p}return c}function De(s,t){const n=s[s.length-1],e=n.offset+n.count>2**16,i=s.reduce((y,u)=>y+u.count,0),c=e?4:2,o=t?new SharedArrayBuffer(i*c):new ArrayBuffer(i*c),l=e?new Uint32Array(o):new Uint16Array(o);let r=0;for(let y=0;y<s.length;y++){const{offset:u,count:f}=s[y];for(let a=0;a<f;a++)l[r+a]=u+a;r+=f}return l}class Fe extends ze{get indirect(){return!!this._indirectBuffer}get primitiveStride(){return null}get primitiveBufferStride(){return this.indirect?1:this.primitiveStride}set primitiveBufferStride(t){}get primitiveBuffer(){return this.indirect?this._indirectBuffer:this.geometry.index.array}set primitiveBuffer(t){}constructor(t,n={}){if(t.isBufferGeometry){if(t.index&&t.index.isInterleavedBufferAttribute)throw new Error("BVH: InterleavedBufferAttribute is not supported for the index attribute.")}else throw new Error("BVH: Only BufferGeometries are supported.");if(n.useSharedArrayBuffer&&!Ue())throw new Error("BVH: SharedArrayBuffer is not available.");super(),this.geometry=t,this.resolvePrimitiveIndex=n.indirect?e=>this._indirectBuffer[e]:e=>e,this.primitiveBuffer=null,this.primitiveBufferStride=null,this._indirectBuffer=null,n={...re,...n},n[Sn]||this.init(n)}init(t){const{geometry:n,primitiveStride:e}=this;if(t.indirect){const i=qn(n,t.range,e),c=De(i,t.useSharedArrayBuffer);this._indirectBuffer=c}else Le(n,t);super.init(t),!n.boundingBox&&t.setBoundingBox&&(n.boundingBox=this.getBoundingBox(new J))}getRootRanges(t){return this.indirect?[{offset:0,count:this._indirectBuffer.length}]:qn(this.geometry,t,this.primitiveStride)}raycastObject3D(){throw new Error("BVH: raycastObject3D() not implemented")}}class nt{constructor(){this.min=1/0,this.max=-1/0}setFromPointsField(t,n){let e=1/0,i=-1/0;for(let c=0,o=t.length;c<o;c++){const r=t[c][n];e=r<e?r:e,i=r>i?r:i}this.min=e,this.max=i}setFromPoints(t,n){let e=1/0,i=-1/0;for(let c=0,o=n.length;c<o;c++){const l=n[c],r=t.dot(l);e=r<e?r:e,i=r>i?r:i}this.min=e,this.max=i}isSeparated(t){return this.min>t.max||t.min>this.max}}nt.prototype.setFromBox=function(){const s=new z;return function(n,e){const i=e.min,c=e.max;let o=1/0,l=-1/0;for(let r=0;r<=1;r++)for(let y=0;y<=1;y++)for(let u=0;u<=1;u++){s.x=i.x*r+c.x*(1-r),s.y=i.y*y+c.y*(1-y),s.z=i.z*u+c.z*(1-u);const f=n.dot(s);o=Math.min(f,o),l=Math.max(f,l)}this.min=o,this.max=l}}();const Ne=function(){const s=new z,t=new z,n=new z;return function(i,c,o){const l=i.start,r=s,y=c.start,u=t;n.subVectors(l,y),s.subVectors(i.end,i.start),t.subVectors(c.end,c.start);const f=n.dot(u),a=u.dot(r),p=u.dot(u),w=n.dot(r),B=r.dot(r)*p-a*a;let A,d;B!==0?A=(f*a-w*p)/B:A=0,d=(f+A*a)/p,o.x=A,o.y=d}}(),vn=function(){const s=new Y,t=new z,n=new z;return function(i,c,o,l){Ne(i,c,s);let r=s.x,y=s.y;if(r>=0&&r<=1&&y>=0&&y<=1){i.at(r,o),c.at(y,l);return}else if(r>=0&&r<=1){y<0?c.at(0,l):c.at(1,l),i.closestPointToPoint(l,!0,o);return}else if(y>=0&&y<=1){r<0?i.at(0,o):i.at(1,o),c.closestPointToPoint(o,!0,l);return}else{let u;r<0?u=i.start:u=i.end;let f;y<0?f=c.start:f=c.end;const a=t,p=n;if(i.closestPointToPoint(f,!0,t),c.closestPointToPoint(u,!0,n),a.distanceToSquared(f)<=p.distanceToSquared(u)){o.copy(a),l.copy(f);return}else{o.copy(u),l.copy(p);return}}}}(),qe=function(){const s=new z,t=new z,n=new se,e=new tt;return function(c,o){const{radius:l,center:r}=c,{a:y,b:u,c:f}=o;if(e.start=y,e.end=u,e.closestPointToPoint(r,!0,s).distanceTo(r)<=l||(e.start=y,e.end=f,e.closestPointToPoint(r,!0,s).distanceTo(r)<=l)||(e.start=u,e.end=f,e.closestPointToPoint(r,!0,s).distanceTo(r)<=l))return!0;const g=o.getPlane(n);if(Math.abs(g.distanceToPoint(r))<=l){const A=g.projectPoint(r,t);if(o.containsPoint(A))return!0}return!1}}(),He=["x","y","z"],G=1e-15,Hn=G*G;function Z(s){return Math.abs(s)<G}class W extends Q{constructor(...t){super(...t),this.isExtendedTriangle=!0,this.satAxes=new Array(4).fill().map(()=>new z),this.satBounds=new Array(4).fill().map(()=>new nt),this.points=[this.a,this.b,this.c],this.plane=new se,this.isDegenerateIntoSegment=!1,this.isDegenerateIntoPoint=!1,this.degenerateSegment=new tt,this.needsUpdate=!0}intersectsSphere(t){return qe(t,this)}update(){const t=this.a,n=this.b,e=this.c,i=this.points,c=this.satAxes,o=this.satBounds,l=c[0],r=o[0];this.getNormal(l),r.setFromPoints(l,i);const y=c[1],u=o[1];y.subVectors(t,n),u.setFromPoints(y,i);const f=c[2],a=o[2];f.subVectors(n,e),a.setFromPoints(f,i);const p=c[3],w=o[3];p.subVectors(e,t),w.setFromPoints(p,i);const g=y.length(),B=f.length(),A=p.length();this.isDegenerateIntoPoint=!1,this.isDegenerateIntoSegment=!1,g<G?B<G||A<G?this.isDegenerateIntoPoint=!0:(this.isDegenerateIntoSegment=!0,this.degenerateSegment.start.copy(t),this.degenerateSegment.end.copy(e)):B<G?A<G?this.isDegenerateIntoPoint=!0:(this.isDegenerateIntoSegment=!0,this.degenerateSegment.start.copy(n),this.degenerateSegment.end.copy(t)):A<G&&(this.isDegenerateIntoSegment=!0,this.degenerateSegment.start.copy(e),this.degenerateSegment.end.copy(n)),this.plane.setFromNormalAndCoplanarPoint(l,t),this.needsUpdate=!1}}W.prototype.closestPointToSegment=function(){const s=new z,t=new z,n=new tt;return function(i,c=null,o=null){const{start:l,end:r}=i,y=this.points;let u,f=1/0;for(let a=0;a<3;a++){const p=(a+1)%3;n.start.copy(y[a]),n.end.copy(y[p]),vn(n,i,s,t),u=s.distanceToSquared(t),u<f&&(f=u,c&&c.copy(s),o&&o.copy(t))}return this.closestPointToPoint(l,s),u=l.distanceToSquared(s),u<f&&(f=u,c&&c.copy(s),o&&o.copy(l)),this.closestPointToPoint(r,s),u=r.distanceToSquared(s),u<f&&(f=u,c&&c.copy(s),o&&o.copy(r)),Math.sqrt(f)}}();W.prototype.intersectsTriangle=function(){const s=new W,t=new nt,n=new nt,e=new z,i=new z,c=new z,o=new z,l=new tt,r=new tt,y=new z,u=new Y,f=new Y;function a(m,x,h,S){const P=e;!m.isDegenerateIntoPoint&&!m.isDegenerateIntoSegment?P.copy(m.plane.normal):P.copy(x.plane.normal);const _=m.satBounds,M=m.satAxes;for(let b=1;b<4;b++){const v=_[b],C=M[b];if(t.setFromPoints(C,x.points),v.isSeparated(t)||(o.copy(P).cross(C),t.setFromPoints(o,m.points),n.setFromPoints(o,x.points),t.isSeparated(n)))return!1}const T=x.satBounds,I=x.satAxes;for(let b=1;b<4;b++){const v=T[b],C=I[b];if(t.setFromPoints(C,m.points),v.isSeparated(t)||(o.crossVectors(P,C),t.setFromPoints(o,m.points),n.setFromPoints(o,x.points),t.isSeparated(n)))return!1}return h&&(S||console.warn("ExtendedTriangle.intersectsTriangle: Triangles are coplanar which does not support an output edge. Setting edge to 0, 0, 0."),h.start.set(0,0,0),h.end.set(0,0,0)),!0}function p(m,x,h,S,P,_,M,T,I,b,v){let C=M/(M-T);b.x=S+(P-S)*C,v.start.subVectors(x,m).multiplyScalar(C).add(m),C=M/(M-I),b.y=S+(_-S)*C,v.end.subVectors(h,m).multiplyScalar(C).add(m)}function w(m,x,h,S,P,_,M,T,I,b,v){if(P>0)p(m.c,m.a,m.b,S,x,h,I,M,T,b,v);else if(_>0)p(m.b,m.a,m.c,h,x,S,T,M,I,b,v);else if(T*I>0||M!=0)p(m.a,m.b,m.c,x,h,S,M,T,I,b,v);else if(T!=0)p(m.b,m.a,m.c,h,x,S,T,M,I,b,v);else if(I!=0)p(m.c,m.a,m.b,S,x,h,I,M,T,b,v);else return!0;return!1}function g(m,x,h,S){const P=x.degenerateSegment,_=m.plane.distanceToPoint(P.start),M=m.plane.distanceToPoint(P.end);return Z(_)?Z(M)?a(m,x,h,S):(h&&(h.start.copy(P.start),h.end.copy(P.start)),m.containsPoint(P.start)):Z(M)?(h&&(h.start.copy(P.end),h.end.copy(P.end)),m.containsPoint(P.end)):m.plane.intersectLine(P,e)!=null?(h&&(h.start.copy(e),h.end.copy(e)),m.containsPoint(e)):!1}function B(m,x,h){const S=x.a;return Z(m.plane.distanceToPoint(S))&&m.containsPoint(S)?(h&&(h.start.copy(S),h.end.copy(S)),!0):!1}function A(m,x,h){const S=m.degenerateSegment,P=x.a;return S.closestPointToPoint(P,!0,e),P.distanceToSquared(e)<Hn?(h&&(h.start.copy(P),h.end.copy(P)),!0):!1}function d(m,x,h,S){if(m.isDegenerateIntoSegment)if(x.isDegenerateIntoSegment){const P=m.degenerateSegment,_=x.degenerateSegment,M=i,T=c;P.delta(M),_.delta(T);const I=e.subVectors(_.start,P.start),b=M.x*T.y-M.y*T.x;if(Z(b))return!1;const v=(I.x*T.y-I.y*T.x)/b,C=-(M.x*I.y-M.y*I.x)/b;if(v<0||v>1||C<0||C>1)return!1;const U=P.start.z+M.z*v,R=_.start.z+T.z*C;return Z(U-R)?(h&&(h.start.copy(P.start).addScaledVector(M,v),h.end.copy(P.start).addScaledVector(M,v)),!0):!1}else return x.isDegenerateIntoPoint?A(m,x,h):g(x,m,h,S);else{if(m.isDegenerateIntoPoint)return x.isDegenerateIntoPoint?x.a.distanceToSquared(m.a)<Hn?(h&&(h.start.copy(m.a),h.end.copy(m.a)),!0):!1:x.isDegenerateIntoSegment?A(x,m,h):B(x,m,h);if(x.isDegenerateIntoPoint)return B(m,x,h);if(x.isDegenerateIntoSegment)return g(m,x,h,S)}}return function(x,h=null,S=!1){this.needsUpdate&&this.update(),x.isExtendedTriangle?x.needsUpdate&&x.update():(s.copy(x),s.update(),x=s);const P=d(this,x,h,S);if(P!==void 0)return P;const _=this.plane,M=x.plane;let T=M.distanceToPoint(this.a),I=M.distanceToPoint(this.b),b=M.distanceToPoint(this.c);Z(T)&&(T=0),Z(I)&&(I=0),Z(b)&&(b=0);const v=T*I,C=T*b;if(v>0&&C>0)return!1;let U=_.distanceToPoint(x.a),R=_.distanceToPoint(x.b),zt=_.distanceToPoint(x.c);Z(U)&&(U=0),Z(R)&&(R=0),Z(zt)&&(zt=0);const Cn=U*R,zn=U*zt;if(Cn>0&&zn>0)return!1;i.copy(_.normal),c.copy(M.normal);const jt=i.cross(c);let Gt=0,tn=Math.abs(jt.x);const Un=Math.abs(jt.y);Un>tn&&(tn=Un,Gt=1),Math.abs(jt.z)>tn&&(Gt=2);const ft=He[Gt],ae=this.a[ft],fe=this.b[ft],ue=this.c[ft],pe=x.a[ft],ye=x.b[ft],de=x.c[ft];if(w(this,ae,fe,ue,v,C,T,I,b,u,l))return a(this,x,h,S);if(w(x,pe,ye,de,Cn,zn,U,R,zt,f,r))return a(this,x,h,S);if(u.y<u.x){const nn=u.y;u.y=u.x,u.x=nn,y.copy(l.start),l.start.copy(l.end),l.end.copy(y)}if(f.y<f.x){const nn=f.y;f.y=f.x,f.x=nn,y.copy(r.start),r.start.copy(r.end),r.end.copy(y)}return u.y<f.x||f.y<u.x?!1:(h&&(f.x>u.x?h.start.copy(r.start):h.start.copy(l.start),f.y<u.y?h.end.copy(r.end):h.end.copy(l.end)),!0)}}();W.prototype.distanceToPoint=function(){const s=new z;return function(n){return this.closestPointToPoint(n,s),n.distanceTo(s)}}();W.prototype.distanceToTriangle=function(){const s=new z,t=new z,n=["a","b","c"],e=new tt,i=new tt;return function(o,l=null,r=null){const y=l||r?e:null;if(this.intersectsTriangle(o,y))return(l||r)&&(l&&y.getCenter(l),r&&y.getCenter(r)),0;let u=1/0;for(let f=0;f<3;f++){let a;const p=n[f],w=o[p];this.closestPointToPoint(w,s),a=w.distanceToSquared(s),a<u&&(u=a,l&&l.copy(s),r&&r.copy(w));const g=this[p];o.closestPointToPoint(g,s),a=g.distanceToSquared(s),a<u&&(u=a,l&&l.copy(g),r&&r.copy(s))}for(let f=0;f<3;f++){const a=n[f],p=n[(f+1)%3];e.set(this[a],this[p]);for(let w=0;w<3;w++){const g=n[w],B=n[(w+1)%3];i.set(o[g],o[B]),vn(e,i,s,t);const A=s.distanceToSquared(t);A<u&&(u=A,l&&l.copy(s),r&&r.copy(t))}}return Math.sqrt(u)}}();class X{constructor(t,n,e){this.isOrientedBox=!0,this.min=new z,this.max=new z,this.matrix=new ot,this.invMatrix=new ot,this.points=new Array(8).fill().map(()=>new z),this.satAxes=new Array(3).fill().map(()=>new z),this.satBounds=new Array(3).fill().map(()=>new nt),this.alignedSatBounds=new Array(3).fill().map(()=>new nt),this.needsUpdate=!1,t&&this.min.copy(t),n&&this.max.copy(n),e&&this.matrix.copy(e)}set(t,n,e){this.min.copy(t),this.max.copy(n),this.matrix.copy(e),this.needsUpdate=!0}copy(t){this.min.copy(t.min),this.max.copy(t.max),this.matrix.copy(t.matrix),this.needsUpdate=!0}}X.prototype.update=function(){return function(){const t=this.matrix,n=this.min,e=this.max,i=this.points;for(let y=0;y<=1;y++)for(let u=0;u<=1;u++)for(let f=0;f<=1;f++){const a=1*y|2*u|4*f,p=i[a];p.x=y?e.x:n.x,p.y=u?e.y:n.y,p.z=f?e.z:n.z,p.applyMatrix4(t)}const c=this.satBounds,o=this.satAxes,l=i[0];for(let y=0;y<3;y++){const u=o[y],f=c[y],a=1<<y,p=i[a];u.subVectors(l,p),f.setFromPoints(u,i)}const r=this.alignedSatBounds;r[0].setFromPointsField(i,"x"),r[1].setFromPointsField(i,"y"),r[2].setFromPointsField(i,"z"),this.invMatrix.copy(this.matrix).invert(),this.needsUpdate=!1}}();X.prototype.intersectsBox=function(){const s=new nt;return function(n){this.needsUpdate&&this.update();const e=n.min,i=n.max,c=this.satBounds,o=this.satAxes,l=this.alignedSatBounds;if(s.min=e.x,s.max=i.x,l[0].isSeparated(s)||(s.min=e.y,s.max=i.y,l[1].isSeparated(s))||(s.min=e.z,s.max=i.z,l[2].isSeparated(s)))return!1;for(let r=0;r<3;r++){const y=o[r],u=c[r];if(s.setFromBox(y,n),u.isSeparated(s))return!1}return!0}}();X.prototype.intersectsTriangle=function(){const s=new W,t=new Array(3),n=new nt,e=new nt,i=new z;return function(o){this.needsUpdate&&this.update(),o.isExtendedTriangle?o.needsUpdate&&o.update():(s.copy(o),s.update(),o=s);const l=this.satBounds,r=this.satAxes;t[0]=o.a,t[1]=o.b,t[2]=o.c;for(let a=0;a<3;a++){const p=l[a],w=r[a];if(n.setFromPoints(w,t),p.isSeparated(n))return!1}const y=o.satBounds,u=o.satAxes,f=this.points;for(let a=0;a<3;a++){const p=y[a],w=u[a];if(n.setFromPoints(w,f),p.isSeparated(n))return!1}for(let a=0;a<3;a++){const p=r[a];for(let w=0;w<4;w++){const g=u[w];if(i.crossVectors(p,g),n.setFromPoints(i,t),e.setFromPoints(i,f),n.isSeparated(e))return!1}}return!0}}();X.prototype.closestPointToPoint=function(){return function(t,n){return this.needsUpdate&&this.update(),n.copy(t).applyMatrix4(this.invMatrix).clamp(this.min,this.max).applyMatrix4(this.matrix),n}}();X.prototype.distanceToPoint=function(){const s=new z;return function(n){return this.closestPointToPoint(n,s),n.distanceTo(s)}}();X.prototype.distanceToBox=function(){const s=["x","y","z"],t=new Array(12).fill().map(()=>new tt),n=new Array(12).fill().map(()=>new tt),e=new z,i=new z;return function(o,l=0,r=null,y=null){if(this.needsUpdate&&this.update(),this.intersectsBox(o))return(r||y)&&(o.getCenter(i),this.closestPointToPoint(i,e),o.closestPointToPoint(e,i),r&&r.copy(e),y&&y.copy(i)),0;const u=l*l,f=o.min,a=o.max,p=this.points;let w=1/0;for(let B=0;B<8;B++){const A=p[B];i.copy(A).clamp(f,a);const d=A.distanceToSquared(i);if(d<w&&(w=d,r&&r.copy(A),y&&y.copy(i),d<u))return Math.sqrt(d)}let g=0;for(let B=0;B<3;B++)for(let A=0;A<=1;A++)for(let d=0;d<=1;d++){const m=(B+1)%3,x=(B+2)%3,h=A<<m|d<<x,S=1<<B|A<<m|d<<x,P=p[h],_=p[S];t[g].set(P,_);const T=s[B],I=s[m],b=s[x],v=n[g],C=v.start,U=v.end;C[T]=f[T],C[I]=A?f[I]:a[I],C[b]=d?f[b]:a[I],U[T]=a[T],U[I]=A?f[I]:a[I],U[b]=d?f[b]:a[I],g++}for(let B=0;B<=1;B++)for(let A=0;A<=1;A++)for(let d=0;d<=1;d++){i.x=B?a.x:f.x,i.y=A?a.y:f.y,i.z=d?a.z:f.z,this.closestPointToPoint(i,e);const m=i.distanceToSquared(e);if(m<w&&(w=m,r&&r.copy(e),y&&y.copy(i),m<u))return Math.sqrt(m)}for(let B=0;B<12;B++){const A=t[B];for(let d=0;d<12;d++){const m=n[d];vn(A,m,e,i);const x=e.distanceToSquared(i);if(x<w&&(w=x,r&&r.copy(e),y&&y.copy(i),x<u))return Math.sqrt(x)}}return Math.sqrt(w)}}();class $e extends Mn{constructor(){super(()=>new W)}}const O=new $e,Bt=new z,an=new z;function ke(s,t,n={},e=0,i=1/0){const c=e*e,o=i*i;let l=1/0,r=null;if(s.shapecast({boundsTraverseOrder:u=>(Bt.copy(t).clamp(u.min,u.max),Bt.distanceToSquared(t)),intersectsBounds:(u,f,a)=>a<l&&a<o,intersectsTriangle:(u,f)=>{u.closestPointToPoint(t,Bt);const a=t.distanceToSquared(Bt);return a<l&&(an.copy(Bt),l=a,r=f),a<c}}),l===1/0)return null;const y=Math.sqrt(l);return n.point?n.point.copy(an):n.point=an.clone(),n.distance=y,n.faceIndex=r,n}const Rt=parseInt(ie)>=169,Xe=parseInt(ie)<=161,ct=new z,lt=new z,at=new z,Vt=new Y,Dt=new Y,Ft=new Y,$n=new z,kn=new z,Xn=new z,Pt=new z;function Ze(s,t,n,e,i,c,o,l){let r;if(c===me?r=s.intersectTriangle(e,n,t,!0,i):r=s.intersectTriangle(t,n,e,c!==xe,i),r===null)return null;const y=s.origin.distanceTo(i);return y<o||y>l?null:{distance:y,point:i.clone()}}function Zn(s,t,n,e,i,c,o,l,r,y,u){ct.fromBufferAttribute(t,c),lt.fromBufferAttribute(t,o),at.fromBufferAttribute(t,l);const f=Ze(s,ct,lt,at,Pt,r,y,u);if(f){if(e){Vt.fromBufferAttribute(e,c),Dt.fromBufferAttribute(e,o),Ft.fromBufferAttribute(e,l),f.uv=new Y;const p=Q.getInterpolation(Pt,ct,lt,at,Vt,Dt,Ft,f.uv);Rt||(f.uv=p)}if(i){Vt.fromBufferAttribute(i,c),Dt.fromBufferAttribute(i,o),Ft.fromBufferAttribute(i,l),f.uv1=new Y;const p=Q.getInterpolation(Pt,ct,lt,at,Vt,Dt,Ft,f.uv1);Rt||(f.uv1=p),Xe&&(f.uv2=f.uv1)}if(n){$n.fromBufferAttribute(n,c),kn.fromBufferAttribute(n,o),Xn.fromBufferAttribute(n,l),f.normal=new z;const p=Q.getInterpolation(Pt,ct,lt,at,$n,kn,Xn,f.normal);f.normal.dot(s.direction)>0&&f.normal.multiplyScalar(-1),Rt||(f.normal=p)}const a={a:c,b:o,c:l,normal:new z,materialIndex:0};if(Q.getNormal(ct,lt,at,a.normal),f.face=a,f.faceIndex=c,Rt){const p=new z;Q.getBarycoord(Pt,ct,lt,at,p),f.barycoord=p}}return f}function On(s){return s&&s.isMaterial?s.side:s}function Jt(s,t,n,e,i,c,o){const l=e*3;let r=l+0,y=l+1,u=l+2;const{index:f,groups:a}=s;s.index&&(r=f.getX(r),y=f.getX(y),u=f.getX(u));const{position:p,normal:w,uv:g,uv1:B}=s.attributes;if(Array.isArray(t)){const A=e*3;for(let d=0,m=a.length;d<m;d++){const{start:x,count:h,materialIndex:S}=a[d];if(A>=x&&A<x+h){const P=On(t[S]),_=Zn(n,p,w,g,B,r,y,u,P,c,o);if(_)if(_.faceIndex=e,_.face.materialIndex=S,i)i.push(_);else return _}}}else{const A=On(t),d=Zn(n,p,w,g,B,r,y,u,A,c,o);if(d)if(d.faceIndex=e,d.face.materialIndex=0,i)i.push(d);else return d}return null}function V(s,t,n,e){const i=s.a,c=s.b,o=s.c;let l=t,r=t+1,y=t+2;n&&(l=n.getX(l),r=n.getX(r),y=n.getX(y)),i.x=e.getX(l),i.y=e.getY(l),i.z=e.getZ(l),c.x=e.getX(r),c.y=e.getY(r),c.z=e.getZ(r),o.x=e.getX(y),o.y=e.getY(y),o.z=e.getZ(y)}const Tt=new z,bt=new z,St=new z,Yn=new Y,Kn=new Y,Wn=new Y;function bs(s,t,n,e){const i=t.getIndex().array,c=t.getAttribute("position"),o=t.getAttribute("uv"),l=i[n*3],r=i[n*3+1],y=i[n*3+2];Tt.fromBufferAttribute(c,l),bt.fromBufferAttribute(c,r),St.fromBufferAttribute(c,y);let u=0;const f=t.groups,a=n*3;for(let g=0,B=f.length;g<B;g++){const A=f[g],{start:d,count:m}=A;if(a>=d&&a<d+m){u=A.materialIndex;break}}const p=e&&e.barycoord?e.barycoord:new z;Q.getBarycoord(s,Tt,bt,St,p);let w=null;return o&&(Yn.fromBufferAttribute(o,l),Kn.fromBufferAttribute(o,r),Wn.fromBufferAttribute(o,y),e&&e.uv?w=e.uv:w=new Y,Q.getInterpolation(s,Tt,bt,St,Yn,Kn,Wn,w)),e?(e.face||(e.face={}),e.face.a=l,e.face.b=r,e.face.c=y,e.face.materialIndex=u,e.face.normal||(e.face.normal=new z),Q.getNormal(Tt,bt,St,e.face.normal),w&&(e.uv=w),e.barycoord=p,e):{face:{a:l,b:r,c:y,materialIndex:u,normal:Q.getNormal(Tt,bt,St,new z)},uv:w,barycoord:p}}function Oe(s,t,n,e,i,c,o,l){const{geometry:r,_indirectBuffer:y}=s;for(let u=e,f=e+i;u<f;u++)Jt(r,t,n,u,c,o,l)}function Ye(s,t,n,e,i,c,o){const{geometry:l,_indirectBuffer:r}=s;let y=1/0,u=null;for(let f=e,a=e+i;f<a;f++){let p;p=Jt(l,t,n,f,null,c,o),p&&p.distance<y&&(u=p,y=p.distance)}return u}function Ke(s,t,n,e,i,c,o){const{geometry:l}=n,{index:r}=l,y=l.attributes.position;for(let u=s,f=t+s;u<f;u++){let a;if(a=u,V(o,a*3,r,y),o.needsUpdate=!0,e(o,a,i,c))return!0}return!1}function We(s,t=null){t&&Array.isArray(t)&&(t=new Set(t));const n=s.geometry,e=n.index?n.index.array:null,i=n.attributes.position;let c,o,l,r,y=0;const u=s._roots;for(let a=0,p=u.length;a<p;a++)c=u[a],o=new Uint32Array(c),l=new Uint16Array(c),r=new Float32Array(c),f(0,y),y+=c.byteLength;function f(a,p,w=!1){const g=a*2;if(F(g,l)){const B=$(a,o),A=k(g,l);let d=1/0,m=1/0,x=1/0,h=-1/0,S=-1/0,P=-1/0;for(let _=3*B,M=3*(B+A);_<M;_++){let T=e[_];const I=i.getX(T),b=i.getY(T),v=i.getZ(T);I<d&&(d=I),I>h&&(h=I),b<m&&(m=b),b>S&&(S=b),v<x&&(x=v),v>P&&(P=v)}return r[a+0]!==d||r[a+1]!==m||r[a+2]!==x||r[a+3]!==h||r[a+4]!==S||r[a+5]!==P?(r[a+0]=d,r[a+1]=m,r[a+2]=x,r[a+3]=h,r[a+4]=S,r[a+5]=P,!0):!1}else{const B=N(a),A=q(a,o);let d=w,m=!1,x=!1;if(t){if(!d){const T=B/D+p/H,I=A/D+p/H;m=t.has(T),x=t.has(I),d=!m&&!x}}else m=!0,x=!0;const h=d||m,S=d||x;let P=!1;h&&(P=f(B,p,d));let _=!1;S&&(_=f(A,p,d));const M=P||_;if(M)for(let T=0;T<3;T++){const I=B+T,b=A+T,v=r[I],C=r[I+3],U=r[b],R=r[b+3];r[a+T]=v<U?v:U,r[a+T+3]=C>R?C:R}return M}}}function rt(s,t,n,e,i){let c,o,l,r,y,u;const f=1/n.direction.x,a=1/n.direction.y,p=1/n.direction.z,w=n.origin.x,g=n.origin.y,B=n.origin.z;let A=t[s],d=t[s+3],m=t[s+1],x=t[s+3+1],h=t[s+2],S=t[s+3+2];return f>=0?(c=(A-w)*f,o=(d-w)*f):(c=(d-w)*f,o=(A-w)*f),a>=0?(l=(m-g)*a,r=(x-g)*a):(l=(x-g)*a,r=(m-g)*a),c>r||l>o||((l>c||isNaN(c))&&(c=l),(r<o||isNaN(o))&&(o=r),p>=0?(y=(h-B)*p,u=(S-B)*p):(y=(S-B)*p,u=(h-B)*p),c>u||y>o)?!1:((y>c||c!==c)&&(c=y),(u<o||o!==o)&&(o=u),c<=i&&o>=e)}function Qe(s,t,n,e,i,c,o,l){const{geometry:r,_indirectBuffer:y}=s;for(let u=e,f=e+i;u<f;u++){let a=y?y[u]:u;Jt(r,t,n,a,c,o,l)}}function Je(s,t,n,e,i,c,o){const{geometry:l,_indirectBuffer:r}=s;let y=1/0,u=null;for(let f=e,a=e+i;f<a;f++){let p;p=Jt(l,t,n,r?r[f]:f,null,c,o),p&&p.distance<y&&(u=p,y=p.distance)}return u}function je(s,t,n,e,i,c,o){const{geometry:l}=n,{index:r}=l,y=l.attributes.position;for(let u=s,f=t+s;u<f;u++){let a;if(a=n.resolveTriangleIndex(u),V(o,a*3,r,y),o.needsUpdate=!0,e(o,a,i,c))return!0}return!1}function Ge(s,t,n,e,i,c,o){E.setBuffer(s._roots[t]),hn(0,s,n,e,i,c,o),E.clearBuffer()}function hn(s,t,n,e,i,c,o){const{float32Array:l,uint16Array:r,uint32Array:y}=E,u=s*2;if(F(u,r)){const a=$(s,y),p=k(u,r);Oe(t,n,e,a,p,i,c,o)}else{const a=N(s);rt(a,l,e,c,o)&&hn(a,t,n,e,i,c,o);const p=q(s,y);rt(p,l,e,c,o)&&hn(p,t,n,e,i,c,o)}}const ts=["x","y","z"];function ns(s,t,n,e,i,c){E.setBuffer(s._roots[t]);const o=wn(0,s,n,e,i,c);return E.clearBuffer(),o}function wn(s,t,n,e,i,c){const{float32Array:o,uint16Array:l,uint32Array:r}=E;let y=s*2;if(F(y,l)){const f=$(s,r),a=k(y,l);return Ye(t,n,e,f,a,i,c)}else{const f=_n(s,r),a=ts[f],w=e.direction[a]>=0;let g,B;w?(g=N(s),B=q(s,r)):(g=q(s,r),B=N(s));const d=rt(g,o,e,i,c)?wn(g,t,n,e,i,c):null;if(d){const h=d.point[a];if(w?h<=o[B+f]:h>=o[B+f+3])return d}const x=rt(B,o,e,i,c)?wn(B,t,n,e,i,c):null;return d&&x?d.distance<=x.distance?d:x:d||x||null}}const Nt=new J,mt=new W,xt=new W,_t=new ot,Qn=new X,qt=new X;function es(s,t,n,e){E.setBuffer(s._roots[t]);const i=An(0,s,n,e);return E.clearBuffer(),i}function An(s,t,n,e,i=null){const{float32Array:c,uint16Array:o,uint32Array:l}=E;let r=s*2;if(i===null&&(n.boundingBox||n.computeBoundingBox(),Qn.set(n.boundingBox.min,n.boundingBox.max,e),i=Qn),F(r,o)){const u=t.geometry,f=u.index,a=u.attributes.position,p=n.index,w=n.attributes.position,g=$(s,l),B=k(r,o);if(_t.copy(e).invert(),n.boundsTree)return L(s,c,qt),qt.matrix.copy(_t),qt.needsUpdate=!0,n.boundsTree.shapecast({intersectsBounds:d=>qt.intersectsBox(d),intersectsTriangle:d=>{d.a.applyMatrix4(e),d.b.applyMatrix4(e),d.c.applyMatrix4(e),d.needsUpdate=!0;for(let m=g*3,x=(B+g)*3;m<x;m+=3)if(V(xt,m,f,a),xt.needsUpdate=!0,d.intersectsTriangle(xt))return!0;return!1}});{const A=Qt(n);for(let d=g*3,m=(B+g)*3;d<m;d+=3){V(mt,d,f,a),mt.a.applyMatrix4(_t),mt.b.applyMatrix4(_t),mt.c.applyMatrix4(_t),mt.needsUpdate=!0;for(let x=0,h=A*3;x<h;x+=3)if(V(xt,x,p,w),xt.needsUpdate=!0,mt.intersectsTriangle(xt))return!0}}}else{const u=N(s),f=q(s,l);return L(u,c,Nt),!!(i.intersectsBox(Nt)&&An(u,t,n,e,i)||(L(f,c,Nt),i.intersectsBox(Nt)&&An(f,t,n,e,i)))}}const Ht=new ot,fn=new X,Mt=new X,ss=new z,is=new z,os=new z,rs=new z;function cs(s,t,n,e={},i={},c=0,o=1/0){t.boundingBox||t.computeBoundingBox(),fn.set(t.boundingBox.min,t.boundingBox.max,n),fn.needsUpdate=!0;const l=s.geometry,r=l.attributes.position,y=l.index,u=t.attributes.position,f=t.index,a=O.getPrimitive(),p=O.getPrimitive();let w=ss,g=is,B=null,A=null;i&&(B=os,A=rs);let d=1/0,m=null,x=null;return Ht.copy(n).invert(),Mt.matrix.copy(Ht),s.shapecast({boundsTraverseOrder:h=>fn.distanceToBox(h),intersectsBounds:(h,S,P)=>P<d&&P<o?(S&&(Mt.min.copy(h.min),Mt.max.copy(h.max),Mt.needsUpdate=!0),!0):!1,intersectsRange:(h,S)=>{if(t.boundsTree)return t.boundsTree.shapecast({boundsTraverseOrder:_=>Mt.distanceToBox(_),intersectsBounds:(_,M,T)=>T<d&&T<o,intersectsRange:(_,M)=>{for(let T=_,I=_+M;T<I;T++){V(p,3*T,f,u),p.a.applyMatrix4(n),p.b.applyMatrix4(n),p.c.applyMatrix4(n),p.needsUpdate=!0;for(let b=h,v=h+S;b<v;b++){V(a,3*b,y,r),a.needsUpdate=!0;const C=a.distanceToTriangle(p,w,B);if(C<d&&(g.copy(w),A&&A.copy(B),d=C,m=b,x=T),C<c)return!0}}}});{const P=Qt(t);for(let _=0,M=P;_<M;_++){V(p,3*_,f,u),p.a.applyMatrix4(n),p.b.applyMatrix4(n),p.c.applyMatrix4(n),p.needsUpdate=!0;for(let T=h,I=h+S;T<I;T++){V(a,3*T,y,r),a.needsUpdate=!0;const b=a.distanceToTriangle(p,w,B);if(b<d&&(g.copy(w),A&&A.copy(B),d=b,m=T,x=_),b<c)return!0}}}}}),O.releasePrimitive(a),O.releasePrimitive(p),d===1/0?null:(e.point?e.point.copy(g):e.point=g.clone(),e.distance=d,e.faceIndex=m,i&&(i.point?i.point.copy(A):i.point=A.clone(),i.point.applyMatrix4(Ht),g.applyMatrix4(Ht),i.distance=g.sub(i.point).length(),i.faceIndex=x),e)}function ls(s,t=null){t&&Array.isArray(t)&&(t=new Set(t));const n=s.geometry,e=n.index?n.index.array:null,i=n.attributes.position;let c,o,l,r,y=0;const u=s._roots;for(let a=0,p=u.length;a<p;a++)c=u[a],o=new Uint32Array(c),l=new Uint16Array(c),r=new Float32Array(c),f(0,y),y+=c.byteLength;function f(a,p,w=!1){const g=a*2;if(F(g,l)){const B=$(a,o),A=k(g,l);let d=1/0,m=1/0,x=1/0,h=-1/0,S=-1/0,P=-1/0;for(let _=B,M=B+A;_<M;_++){const T=3*s.resolveTriangleIndex(_);for(let I=0;I<3;I++){let b=T+I;b=e?e[b]:b;const v=i.getX(b),C=i.getY(b),U=i.getZ(b);v<d&&(d=v),v>h&&(h=v),C<m&&(m=C),C>S&&(S=C),U<x&&(x=U),U>P&&(P=U)}}return r[a+0]!==d||r[a+1]!==m||r[a+2]!==x||r[a+3]!==h||r[a+4]!==S||r[a+5]!==P?(r[a+0]=d,r[a+1]=m,r[a+2]=x,r[a+3]=h,r[a+4]=S,r[a+5]=P,!0):!1}else{const B=N(a),A=q(a,o);let d=w,m=!1,x=!1;if(t){if(!d){const T=B/D+p/H,I=A/D+p/H;m=t.has(T),x=t.has(I),d=!m&&!x}}else m=!0,x=!0;const h=d||m,S=d||x;let P=!1;h&&(P=f(B,p,d));let _=!1;S&&(_=f(A,p,d));const M=P||_;if(M)for(let T=0;T<3;T++){const I=B+T,b=A+T,v=r[I],C=r[I+3],U=r[b],R=r[b+3];r[a+T]=v<U?v:U,r[a+T+3]=C>R?C:R}return M}}}function as(s,t,n,e,i,c,o){E.setBuffer(s._roots[t]),gn(0,s,n,e,i,c,o),E.clearBuffer()}function gn(s,t,n,e,i,c,o){const{float32Array:l,uint16Array:r,uint32Array:y}=E,u=s*2;if(F(u,r)){const a=$(s,y),p=k(u,r);Qe(t,n,e,a,p,i,c,o)}else{const a=N(s);rt(a,l,e,c,o)&&gn(a,t,n,e,i,c,o);const p=q(s,y);rt(p,l,e,c,o)&&gn(p,t,n,e,i,c,o)}}const fs=["x","y","z"];function us(s,t,n,e,i,c){E.setBuffer(s._roots[t]);const o=Bn(0,s,n,e,i,c);return E.clearBuffer(),o}function Bn(s,t,n,e,i,c){const{float32Array:o,uint16Array:l,uint32Array:r}=E;let y=s*2;if(F(y,l)){const f=$(s,r),a=k(y,l);return Je(t,n,e,f,a,i,c)}else{const f=_n(s,r),a=fs[f],w=e.direction[a]>=0;let g,B;w?(g=N(s),B=q(s,r)):(g=q(s,r),B=N(s));const d=rt(g,o,e,i,c)?Bn(g,t,n,e,i,c):null;if(d){const h=d.point[a];if(w?h<=o[B+f]:h>=o[B+f+3])return d}const x=rt(B,o,e,i,c)?Bn(B,t,n,e,i,c):null;return d&&x?d.distance<=x.distance?d:x:d||x||null}}const $t=new J,ht=new W,wt=new W,It=new ot,Jn=new X,kt=new X;function ps(s,t,n,e){E.setBuffer(s._roots[t]);const i=Pn(0,s,n,e);return E.clearBuffer(),i}function Pn(s,t,n,e,i=null){const{float32Array:c,uint16Array:o,uint32Array:l}=E;let r=s*2;if(i===null&&(n.boundingBox||n.computeBoundingBox(),Jn.set(n.boundingBox.min,n.boundingBox.max,e),i=Jn),F(r,o)){const u=t.geometry,f=u.index,a=u.attributes.position,p=n.index,w=n.attributes.position,g=$(s,l),B=k(r,o);if(It.copy(e).invert(),n.boundsTree)return L(s,c,kt),kt.matrix.copy(It),kt.needsUpdate=!0,n.boundsTree.shapecast({intersectsBounds:d=>kt.intersectsBox(d),intersectsTriangle:d=>{d.a.applyMatrix4(e),d.b.applyMatrix4(e),d.c.applyMatrix4(e),d.needsUpdate=!0;for(let m=g,x=B+g;m<x;m++)if(V(wt,3*t.resolveTriangleIndex(m),f,a),wt.needsUpdate=!0,d.intersectsTriangle(wt))return!0;return!1}});{const A=Qt(n);for(let d=g,m=B+g;d<m;d++){const x=t.resolveTriangleIndex(d);V(ht,3*x,f,a),ht.a.applyMatrix4(It),ht.b.applyMatrix4(It),ht.c.applyMatrix4(It),ht.needsUpdate=!0;for(let h=0,S=A*3;h<S;h+=3)if(V(wt,h,p,w),wt.needsUpdate=!0,ht.intersectsTriangle(wt))return!0}}}else{const u=N(s),f=q(s,l);return L(u,c,$t),!!(i.intersectsBox($t)&&Pn(u,t,n,e,i)||(L(f,c,$t),i.intersectsBox($t)&&Pn(f,t,n,e,i)))}}const Xt=new ot,un=new X,vt=new X,ys=new z,ds=new z,ms=new z,xs=new z;function hs(s,t,n,e={},i={},c=0,o=1/0){t.boundingBox||t.computeBoundingBox(),un.set(t.boundingBox.min,t.boundingBox.max,n),un.needsUpdate=!0;const l=s.geometry,r=l.attributes.position,y=l.index,u=t.attributes.position,f=t.index,a=O.getPrimitive(),p=O.getPrimitive();let w=ys,g=ds,B=null,A=null;i&&(B=ms,A=xs);let d=1/0,m=null,x=null;return Xt.copy(n).invert(),vt.matrix.copy(Xt),s.shapecast({boundsTraverseOrder:h=>un.distanceToBox(h),intersectsBounds:(h,S,P)=>P<d&&P<o?(S&&(vt.min.copy(h.min),vt.max.copy(h.max),vt.needsUpdate=!0),!0):!1,intersectsRange:(h,S)=>{if(t.boundsTree){const P=t.boundsTree;return P.shapecast({boundsTraverseOrder:_=>vt.distanceToBox(_),intersectsBounds:(_,M,T)=>T<d&&T<o,intersectsRange:(_,M)=>{for(let T=_,I=_+M;T<I;T++){const b=P.resolveTriangleIndex(T);V(p,3*b,f,u),p.a.applyMatrix4(n),p.b.applyMatrix4(n),p.c.applyMatrix4(n),p.needsUpdate=!0;for(let v=h,C=h+S;v<C;v++){const U=s.resolveTriangleIndex(v);V(a,3*U,y,r),a.needsUpdate=!0;const R=a.distanceToTriangle(p,w,B);if(R<d&&(g.copy(w),A&&A.copy(B),d=R,m=v,x=T),R<c)return!0}}}})}else{const P=Qt(t);for(let _=0,M=P;_<M;_++){V(p,3*_,f,u),p.a.applyMatrix4(n),p.b.applyMatrix4(n),p.c.applyMatrix4(n),p.needsUpdate=!0;for(let T=h,I=h+S;T<I;T++){const b=s.resolveTriangleIndex(T);V(a,3*b,y,r),a.needsUpdate=!0;const v=a.distanceToTriangle(p,w,B);if(v<d&&(g.copy(w),A&&A.copy(B),d=v,m=T,x=_),v<c)return!0}}}}}),O.releasePrimitive(a),O.releasePrimitive(p),d===1/0?null:(e.point?e.point.copy(g):e.point=g.clone(),e.distance=d,e.faceIndex=m,i&&(i.point?i.point.copy(A):i.point=A.clone(),i.point.applyMatrix4(Xt),g.applyMatrix4(Xt),i.distance=g.sub(i.point).length(),i.faceIndex=x),e)}function jn(s,t,n){return s===null?null:(s.point.applyMatrix4(t.matrixWorld),s.distance=s.point.distanceTo(n.ray.origin),s.object=t,s)}const Zt=new X,Ot=new he,Gn=new z,te=new ot,ne=new z,pn=["getX","getY","getZ"];class Tn extends Fe{static serialize(t,n={}){n={cloneBuffers:!0,...n};const e=t.geometry,i=t._roots,c=t._indirectBuffer,o=e.getIndex(),l={version:1,roots:null,index:null,indirectBuffer:null};return n.cloneBuffers?(l.roots=i.map(r=>r.slice()),l.index=o?o.array.slice():null,l.indirectBuffer=c?c.slice():null):(l.roots=i,l.index=o?o.array:null,l.indirectBuffer=c),l}static deserialize(t,n,e={}){e={setIndex:!0,indirect:!!t.indirectBuffer,...e};const{index:i,roots:c,indirectBuffer:o}=t;t.version||(console.warn("MeshBVH.deserialize: Serialization format has been changed and will be fixed up. It is recommended to regenerate any stored serialized data."),r(c));const l=new Tn(n,{...e,[Sn]:!0});if(l._roots=c,l._indirectBuffer=o||null,e.setIndex){const y=n.getIndex();if(y===null){const u=new ee(t.index,1,!1);n.setIndex(u)}else y.array!==i&&(y.array.set(i),y.needsUpdate=!0)}return l;function r(y){for(let u=0;u<y.length;u++){const f=y[u],a=new Uint32Array(f),p=new Uint16Array(f);for(let w=0,g=f.byteLength/H;w<g;w++){const B=D*w,A=2*B;F(A,p)||(a[B+6]=a[B+6]/D-w)}}}}get primitiveStride(){return 3}get resolveTriangleIndex(){return this.resolvePrimitiveIndex}constructor(t,n={}){n.maxLeafTris&&(console.warn('MeshBVH: "maxLeafTris" option has been deprecated. Use maxLeafSize, instead.'),n={...n,maxLeafSize:n.maxLeafTris}),super(t,n)}shiftTriangleOffsets(t){return super.shiftPrimitiveOffsets(t)}writePrimitiveBounds(t,n,e){const i=this.geometry,c=this._indirectBuffer,o=i.attributes.position,l=i.index?i.index.array:null,y=(c?c[t]:t)*3;let u=y+0,f=y+1,a=y+2;l&&(u=l[u],f=l[f],a=l[a]);for(let p=0;p<3;p++){const w=o[pn[p]](u),g=o[pn[p]](f),B=o[pn[p]](a);let A=w;g<A&&(A=g),B<A&&(A=B);let d=w;g>d&&(d=g),B>d&&(d=B),n[e+p]=A,n[e+p+3]=d}return n}computePrimitiveBounds(t,n,e){const i=this.geometry,c=this._indirectBuffer,o=i.attributes.position,l=i.index?i.index.array:null,r=o.normalized;if(t<0||n+t-e.offset>e.length/6)throw new Error("MeshBVH: compute triangle bounds range is invalid.");const y=o.array,u=o.offset||0;let f=3;o.isInterleavedBufferAttribute&&(f=o.data.stride);const a=["getX","getY","getZ"],p=e.offset;for(let w=t,g=t+n;w<g;w++){const A=(c?c[w]:w)*3,d=(w-p)*6;let m=A+0,x=A+1,h=A+2;l&&(m=l[m],x=l[x],h=l[h]),r||(m=m*f+u,x=x*f+u,h=h*f+u);for(let S=0;S<3;S++){let P,_,M;r?(P=o[a[S]](m),_=o[a[S]](x),M=o[a[S]](h)):(P=y[m+S],_=y[x+S],M=y[h+S]);let T=P;_<T&&(T=_),M<T&&(T=M);let I=P;_>I&&(I=_),M>I&&(I=M);const b=(I-T)/2,v=S*2;e[d+v+0]=T+b,e[d+v+1]=b+(Math.abs(T)+b)*Yt}}return e}raycastObject3D(t,n,e=[]){const{material:i}=t;if(i===void 0)return;te.copy(t.matrixWorld).invert(),Ot.copy(n.ray).applyMatrix4(te),ne.setFromMatrixScale(t.matrixWorld),Gn.copy(Ot.direction).multiply(ne);const c=Gn.length(),o=n.near/c,l=n.far/c;if(n.firstHitOnly===!0){let r=this.raycastFirst(Ot,i,o,l);r=jn(r,t,n),r&&e.push(r)}else{const r=this.raycast(Ot,i,o,l);for(let y=0,u=r.length;y<u;y++){const f=jn(r[y],t,n);f&&e.push(f)}}return e}refit(t=null){return(this.indirect?ls:We)(this,t)}raycast(t,n=En,e=0,i=1/0){const c=this._roots,o=[],l=this.indirect?as:Ge;for(let r=0,y=c.length;r<y;r++)l(this,r,n,t,o,e,i);return o}raycastFirst(t,n=En,e=0,i=1/0){const c=this._roots;let o=null;const l=this.indirect?us:ns;for(let r=0,y=c.length;r<y;r++){const u=l(this,r,n,t,e,i);u!=null&&(o==null||u.distance<o.distance)&&(o=u)}return o}intersectsGeometry(t,n){let e=!1;const i=this._roots,c=this.indirect?ps:es;for(let o=0,l=i.length;o<l&&(e=c(this,o,t,n),!e);o++);return e}shapecast(t){const n=O.getPrimitive(),e=super.shapecast({...t,intersectsPrimitive:t.intersectsTriangle,scratchPrimitive:n,iterate:this.indirect?je:Ke});return O.releasePrimitive(n),e}bvhcast(t,n,e){let{intersectsRanges:i,intersectsTriangles:c}=e;const o=O.getPrimitive(),l=this.geometry.index,r=this.geometry.attributes.position,y=this.indirect?w=>{const g=this.resolveTriangleIndex(w);V(o,g*3,l,r)}:w=>{V(o,w*3,l,r)},u=O.getPrimitive(),f=t.geometry.index,a=t.geometry.attributes.position,p=t.indirect?w=>{const g=t.resolveTriangleIndex(w);V(u,g*3,f,a)}:w=>{V(u,w*3,f,a)};if(c){if(!(t instanceof Tn))throw new Error('MeshBVH: "intersectsTriangles" callback can only be used with another MeshBVH.');const w=(g,B,A,d,m,x,h,S)=>{for(let P=A,_=A+d;P<_;P++){p(P),u.a.applyMatrix4(n),u.b.applyMatrix4(n),u.c.applyMatrix4(n),u.needsUpdate=!0;for(let M=g,T=g+B;M<T;M++)if(y(M),o.needsUpdate=!0,c(o,u,M,P,m,x,h,S))return!0}return!1};if(i){const g=i;i=function(B,A,d,m,x,h,S,P){return g(B,A,d,m,x,h,S,P)?!0:w(B,A,d,m,x,h,S,P)}}else i=w}return super.bvhcast(t,n,{intersectsRanges:i})}intersectsBox(t,n){return Zt.set(t.min,t.max,n),Zt.needsUpdate=!0,this.shapecast({intersectsBounds:e=>Zt.intersectsBox(e),intersectsTriangle:e=>Zt.intersectsTriangle(e)})}intersectsSphere(t){return this.shapecast({intersectsBounds:n=>t.intersectsBox(n),intersectsTriangle:n=>n.intersectsSphere(t)})}closestPointToGeometry(t,n,e={},i={},c=0,o=1/0){return(this.indirect?hs:cs)(this,t,n,e,i,c,o)}closestPointToPoint(t,n={},e=0,i=1/0){return ke(this,t,n,e,i)}}export{we as A,H as B,k as C,W as E,Fe as G,Bs as I,Ps as L,Tn as M,gs as N,$ as O,Mn as P,_n as S,Rn as T,L as a,en as b,In as c,F as d,Ts as e,oe as f,Ee as g,Ae as h,Ue as i,Ln as j,Sn as k,bs as l,ze as m,De as n,X as o};
